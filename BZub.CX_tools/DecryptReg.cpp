/*
    Decrypt Reg  
    -
    INTECO-CERT
    -
    David Reguera García 
    david.reguera@inteco.es
*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <windows.h>

#define BLOCKS         6*3
#define INIT_VALUE     4
#define MAX_KEY_LENGTH 255
#define MAX_VALUE_NAME 16383
#define TROYAN_SUBKEY  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\load"

void WriteDump      ( FILE *, unsigned char *, int );
void ShowBlock      ( FILE *, int, unsigned char *, char * );
int  DecryptReg     ( FILE * );
int  _DecryptReg    ( FILE *, char *, unsigned char *, int );
void __DecryptReg   ( unsigned char *, int );
 
int main( int argc, char * argv[] )
{
    int    return_function;
    FILE * dump_file;
    
    puts
    (
        "\n"
        " David Reguera Garcia                        \n"
        " --------------------------------------------\n"
        " Decrypt Reg  [ v1.0 ]    -    INTECO-CERT   \n"
        "____________________________________________________\n\n"
    );
    
    return_function = 0;
    
    if ( argc < 2 )
        dump_file = stdout;
    else
    {
        dump_file = fopen( argv[1], "a" );
        if ( dump_file == NULL )
        {
            perror( "" );
            return_function = -1;
        }
    }
    
    if ( return_function == 0 )
    {
        return_function = DecryptReg( dump_file );

        if ( argc < 2 )
            if ( fclose( dump_file ) == EOF )
                perror( "" );
    }

    getchar();

    return return_function;
} 
 
int DecryptReg( FILE * file_dump ) 
{ 
    TCHAR    achKey[MAX_KEY_LENGTH];         // buffer for subkey name
    DWORD    cbName;                         // size of name string 
    TCHAR    achClass[MAX_PATH] = TEXT("");  // buffer for class name 
    DWORD    cchClassName = MAX_PATH;        // size of class string 
    DWORD    cSubKeys=0;                     // number of subkeys 
    DWORD    cbMaxSubKey;                    // longest subkey size 
    DWORD    cchMaxClass;                    // longest class string 
    DWORD    cValues;                        // number of values for key 
    DWORD    cchMaxValue;                    // longest value name 
    DWORD    cbMaxValueData;                 // longest value data 
    DWORD    cbSecurityDescriptor;           // size of security descriptor 
    FILETIME ftLastWriteTime;                // last write time 
    BYTE   * value_data;
    int      total;
    DWORD    i, retCode; 
    TCHAR    achValue[MAX_VALUE_NAME]; 
    DWORD    cchValue = MAX_VALUE_NAME;
    HKEY     hKey;
    LPVOID   lpMsgBuf;
    LPVOID   lpDisplayBuf;
    int      return_function;

    return_function = 0;

    if 
    (
        RegOpenKeyExA
        ( 
            HKEY_LOCAL_MACHINE     , 
            (LPCSTR) TROYAN_SUBKEY ,
            0                      ,
            KEY_READ               ,
            & hKey    
        )
        !=
        ERROR_SUCCESS
    )
    {
        puts( " No se ha podido acceder a la clave load." );
        return -1;
    } 

    retCode = \
        RegQueryInfoKey
        (
            hKey                   , // key handle 
            achClass               , // buffer for class name 
            & cchClassName         , // size of class string 
            NULL                   , // reserved 
            & cSubKeys             , // number of subkeys 
            & cbMaxSubKey          , // longest subkey size 
            & cchMaxClass          , // longest class string 
            & cValues              , // number of values for this key 
            & cchMaxValue          , // longest value name 
            & cbMaxValueData       , // longest value data 
            & cbSecurityDescriptor , // security descriptor 
            & ftLastWriteTime        // last write time 
        );  
    
    if ( retCode != ERROR_SUCCESS )
    {
        puts( " Error al obtener informacion sobre la clave load.\n" );
        return_function = -1;
    }     
 
    if ( return_function == 0 )
    {
        total = cbMaxValueData;
    
        value_data = (BYTE *) calloc( 1, total );
        if ( value_data == NULL )
        {
            puts( " Error al asignar memoria dinamicamente." );
            return -1;
        }
    }

    if ( return_function == 0 )
    {
        if ( cValues ) 
        {
            fprintf( file_dump, "\n Numero de campos: %d\n", cValues );

            for ( i = 0, retCode = ERROR_SUCCESS; i < cValues; i++ ) 
            { 
                cbMaxValueData = total;
                cchValue       = MAX_VALUE_NAME; 
                achValue[0]    = '\0'; 
            
                retCode = \
                    RegEnumValue
                    (
                        hKey               , 
                        i                  , 
                        achValue           , 
                        & cchValue         , 
                        NULL               , 
                        NULL               ,
                        value_data         ,
                        & cbMaxValueData
                    );
 
                if (retCode == ERROR_SUCCESS ) 
                    _DecryptReg( file_dump, achValue, value_data, cbMaxValueData );
                else
                {
                    printf( " retCode: %d: ", retCode );

                    if 
                    (
                            FormatMessage
                            (
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM ,
                            NULL                                                        ,
                            retCode                                                     ,
                            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT )                 ,
                            (LPTSTR) &lpMsgBuf                                          ,
                            0                                                           , 
                            NULL 
                        )
                        != 
                        0
                    )
                    {
                        puts( (const char *) lpMsgBuf );
                        LocalFree( lpMsgBuf );
                    }
                    else
                        puts( " Error en FormatMessage.\n" );
                }
            }
        }
    }
    
    if ( RegCloseKey( hKey ) != ERROR_SUCCESS )
        puts( " Error: al cerrar el manejador del registro.\n" );
    
    return return_function;
}

int _DecryptReg( FILE * file_dump, char * value_name, unsigned char * value_data, int value_data_size )
{  
    fprintf( file_dump, "\n\n Mostrando descifrado: %s\n\n", value_name );

    fprintf
    ( 
        file_dump                         ,
        
        " Valor del registro descifrado:\n" 
        " ==============================\n\n"
    );
    
    __DecryptReg( value_data, value_data_size );
    
    WriteDump( file_dump, value_data, value_data_size );

    return 0;
}

void __DecryptReg( unsigned char * string, int size_data )
{
    int i;
    unsigned int init_value;
    unsigned int new_char;
    
    init_value = INIT_VALUE;
    
    for ( i = init_value; i < size_data; i++ )
    {
        new_char   = init_value;
        new_char  *= init_value;
        new_char  &= 0xFF;
        string[i] ^= new_char;
        init_value++;
    }
} 

void WriteDump( FILE * file_dump, unsigned char * data_dump, int size_dump )
{
    int          i;
    int          blocks = BLOCKS;
    unsigned int total_blocks;
    unsigned int size_last_block;
    unsigned int actual_size_block;
    
    fprintf
    ( 
        file_dump,
        
        " HEX                  |  ASCII            \n"
        " ------------------------------------------\n"
    );
    
    total_blocks    = size_dump / blocks;
    size_last_block = size_dump % blocks;
    
    if ( size_last_block > 0 )
        total_blocks++;
    
    actual_size_block = BLOCKS; 
       
    for ( i = 0; i < total_blocks; i++ )
    {
        if ( size_last_block > 0 )
            if ( i == (total_blocks - 1) )
                actual_size_block = size_last_block;    
        ShowBlock( file_dump, actual_size_block, & data_dump[BLOCKS * i], "HEX" );
        fprintf( file_dump, "    | " );
        ShowBlock( file_dump, actual_size_block, & data_dump[BLOCKS * i], "ASC" );
        fprintf( file_dump, "\n" );
    }
}

void ShowBlock( FILE * file_dump, int blocks, unsigned char * data_block, char * type )
{
    int i;
    
    for ( i = 0; i < blocks; i++ )
    {    
        if ( strcmp( type, "ASC" ) == 0 )
            if ( isprint( data_block[i] ) )
                fprintf( file_dump, " %c", data_block[i] );
            else
                fprintf( file_dump, " " );
        else
            fprintf( file_dump, " %02X", data_block[i] );
    }
}

